<!DOCTYPE html>
<html>
  <head>
    <title>opencascade.js Examples</title>
  </head>
  <body>
    <h1>Examples</h1>
    <ul>
      <li><a href="demos/Joists/index.html">Open Web Steel Joist</a></li>
      <ul>
        <li>
          Models a parametric open web steel joist with back-to-back angle
          chords. SLOW
        </li>
      </ul>
      <li><a href="demos/BaysOfJoists">Bays of Joists</a></li>
      <ul>
        <li>
          Creates a building roof structure with 250 open web steel joists
          arranged in 5 bays of 50 joists each, spaced 8 feet apart. SLOW
        </li>
      </ul>
      <li><a href="demos/BiggerBaysOfJoists/">Bigger Bays of Joists</a></li>
      <ul>
        <li>
          Creates a building roof structure with 1000 open web steel joists
          arranged in 10 bays of 100 joists each, spaced 8 feet apart. SLOW
        </li>
      </ul>
      <li>
        <a href="demos/TallerAndBiggerBaysOfJoists/"
          >Taller & Bigger Bays of Joists</a
        >
      </li>
      <ul>
        <li>
          Creates a multi-story building structure with 5000 open web steel
          joists arranged in 5 floors of 10 bays with 100 joists each. Story
          height: 32 feet. Same joist copied, so not realistic
        </li>
      </ul>
      <li>
        <a href="demos/WhatIfTheJoistsAreDifferent/"
          >What If The Joists Are All Different</a
        >
      </li>
      <ul>
        <li>
          Creates the same multi-story building, but treats each joist as unique
          to test performance. TAKES LIKE 15 MINUTES SO I DON'T RECOMMEND IT
          CLICKING THIS LINK. TRY THE ONE BELOW INSTEAD.
        </li>
      </ul>
      <li>
        <a href="demos/WhatIfTheJoistsAreDifferentButFastToo/"
          >What If The Joists Are All Different But Fast Too</a
        >
      </li>
      <ul>
        <li>
          Creates the same multi-story building, but uses a faster algorithm for
          rendering. Simulates 5000 joists with 1000 unique marks.
        </li>
        <li>
          OpenCascade is doing the geometric modeling and tessellation. Three.js
          handles all the rendering. The speed comes from doing the expensive
          OpenCascade work once upfront, then using fast GPU rendering for the
          5000 instances.
        </li>
        <li>
          This simulates an architecture where OpenCascade does the heavy
          geometric lifting during library creation, but runtime instantiation
          is just fast data lookups and GPU rendering.
        </li>
        <li>
          The idea would be we represent our models using a library of
          predefined shapes and objects that are parameterized.
          Any tool could then pluck what component they need from the library
          and instantiate it quickly, without needing to do the heavy OpenCascade
          work again. Extending it or new demands is easy to handle.
        </li>
      </ul>
      <li>
        <a href="demos/TheBigKahuna/"
          >ðŸŒº The Big Kahuna - Ultimate Stress Test ðŸŒº</a
        >
      </li>
      <ul>
        <li>
          <strong>THE ULTIMATE STRESS TEST:</strong> Creates a massive 10-story
          building with <strong>10,000 open web steel joists</strong> using ~10000
          unique marks from a pre-tessellated library.
        </li>
        <li>
          <strong>Building specs:</strong> 10 floors Ã— 10 bays Ã— 100 joists per
          bay = 10,000 total joists. Building height: 320 feet. Uses the same
          fast library-based approach but scaled up.
        </li>
        <li>
          <strong>Library approach:</strong> 10000 pre-tessellated joist variants
          with expanded specifications (Various lengths, depths, web
          patterns, multiple steel grades etc.). Simulates a comprehensive structural
          engineering library.
        </li>
        <li>
          <strong>Performance target:</strong> Lightning-fast instantiation
          regardless of complexity. Tests the absolute limits of the
          library-based approach with realistic building scale.
        </li>
      </ul>
    </ul>

    <hr>

    <h3>How This Works: A Scalable Architecture for Complex 3D Geometry</h3>
    <p>
      The demos above illustrate a journey from a slow, "brute-force" approach to a highly optimized, library-based architecture. The final and fastest examples, like "The Big Kahuna," simulate a powerful real-world strategy. The following is a summary of that proposed architecture.
    </p>

    <h4>1. The Core Problem: Runtime Geometric Modeling is Slow</h4>
    <p>
      The initial demos (<code>Joists</code>, <code>BaysOfJoists</code>, etc.) build each joist from scratch every time it's needed. This involves numerous complex calculations using the OpenCascade geometry kernel. While precise, this process is computationally expensive. As seen in the <code>WhatIfTheJoistsAreDifferent</code> demo, when you try to create thousands of unique objects this way, the performance overhead of constantly communicating with the geometry engine becomes a major bottleneck, leading to very long load times.
    </p>

    <h4>2. The Solution Part 1: A Library of Precise Components</h4>
    <p>
      Instead of building entire joists at runtime, the optimized approach is to create a library of fundamental <strong>components</strong>. The key difference is that these components are stored as a precise, mathematical representation known as <strong>NURBS</strong> (Non-Uniform Rational B-Splines).
    </p>
    <p>
      In this model, the OpenCascade C++ engine performs the heavy geometric modeling for each component <strong>once</strong> to generate this NURBS data. The library would contain:
    </p>
    <ul>
      <li>Every type and size of <strong>angle</strong>, <strong>rod</strong>, and <strong>gusset plate</strong></li>
      <li>Various <strong>bolts, welds</strong>, and other connection hardware</li>
    </ul>
    <p>
      Each of these items is stored in the library as a lightweight, precise NURBS object. This "library creation" is a one-time, upfront cost.
    </p>

    <h4>3. The Solution Part 2: Lightweight Assembly and Discretization</h4>
    <p>
      At runtime, the application acts as an assembler. When it needs to build a unique joist:
    </p>
    <ol>
      <li> It determines which NURBS components are needed.</li>
      <li> It performs a nearly instantaneous lookup from the library to get the NURBS data for each part.</li>
      <li> It <strong>assembles</strong> the final joist by positioning these NURBS components.</li>
    </ol>
    <p>
      Only after the complete, unique joist is assembled at this mathematical level does the final step, <strong>discretization</strong> (or tessellation), occur. This is the process of converting the precise NURBS geometry of the final assembly into triangles that the GPU can render.
    </p>

    <h4>4. The Rendering Engine: Full Control with Keystone.js</h4>
    <p>
      Instead of using a general-purpose rendering library like Three.js, this architecture uses a lightweight, in-house script (referred to as <code>MeshGL.js</code> or <code>Keystone.js</code>). This script's job is to take the triangulated geometry from the discretization step and feed it directly to the GPU for rendering.
    </p>
    <p>
      The reason for this is <strong>complete control</strong>. Using a custom rendering engine ensures that every part of the process is understood and can be optimized. If performance issues arise, there are no ambiguities from a third-party library; every "dusty corner" of the rendering pipeline is accessible for troubleshooting and enhancement.
    </p>
  </body>
</html>